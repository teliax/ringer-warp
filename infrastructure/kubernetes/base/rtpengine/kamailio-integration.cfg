# RTPEngine Integration for Kamailio
# This configuration snippet should be included in your Kamailio configuration

#!define RTPENGINE_LIST "udp:34.123.38.31:2223=1 udp:35.222.101.214:2223=1 udp:35.225.65.80:2223=1"

# Load RTPEngine module
loadmodule "rtpengine.so"

# RTPEngine module parameters
modparam("rtpengine", "rtpengine_sock", RTPENGINE_LIST)
modparam("rtpengine", "rtpengine_disable_tout", 20)
modparam("rtpengine", "rtpengine_tout_ms", 2000)
modparam("rtpengine", "rtpengine_retr", 5)
modparam("rtpengine", "extra_id_pv", "$avp(extra_id)")
modparam("rtpengine", "setid_avp", "$avp(setid)")

# RTPEngine control functions
route[RTPENGINE] {
    # Check if this is a WebRTC client
    if ($ru =~ "transport=ws") {
        $avp(rtpengine_offer_flags) = "trust-address replace-origin replace-session-connection ICE=force RTP/SAVPF DTLS=passive";
        $avp(rtpengine_answer_flags) = "trust-address replace-origin replace-session-connection ICE=force RTP/SAVPF DTLS=passive";
    } else {
        $avp(rtpengine_offer_flags) = "trust-address replace-origin replace-session-connection RTP/AVP";
        $avp(rtpengine_answer_flags) = "trust-address replace-origin replace-session-connection RTP/AVP";
    }
    
    # Add recording flag if needed
    if ($avp(record_call) == 1) {
        $avp(rtpengine_offer_flags) = $avp(rtpengine_offer_flags) + " record-call=yes";
        $avp(rtpengine_answer_flags) = $avp(rtpengine_answer_flags) + " record-call=yes";
    }
    
    # Set codec preferences
    $avp(rtpengine_offer_flags) = $avp(rtpengine_offer_flags) + " codec-mask=all codec-transcode=PCMU,PCMA,opus,G722";
}

# Handle NAT for RTP
route[NATMANAGE] {
    if (is_method("INVITE|UPDATE|ACK|BYE|CANCEL")) {
        if (has_body("application/sdp")) {
            route(RTPENGINE);
            
            if (is_method("INVITE")) {
                if ($avp(rtpengine_offer_flags) != $null) {
                    rtpengine_offer($avp(rtpengine_offer_flags));
                } else {
                    rtpengine_offer();
                }
            } else if (is_method("ACK") && has_body("application/sdp")) {
                if ($avp(rtpengine_answer_flags) != $null) {
                    rtpengine_answer($avp(rtpengine_answer_flags));
                } else {
                    rtpengine_answer();
                }
            } else if (is_method("UPDATE")) {
                if (has_body("application/sdp")) {
                    if ($avp(rtpengine_offer_flags) != $null) {
                        rtpengine_offer($avp(rtpengine_offer_flags));
                    } else {
                        rtpengine_offer();
                    }
                }
            }
        }
    }
}

# Handle responses
onreply_route[REPLY_RTPENGINE] {
    if (has_body("application/sdp")) {
        if ($rs =~ "18[03]") {
            # Early media
            if ($avp(rtpengine_answer_flags) != $null) {
                rtpengine_answer($avp(rtpengine_answer_flags));
            } else {
                rtpengine_answer();
            }
        } else if ($rs =~ "2[0-9][0-9]" && $rm == "INVITE") {
            # Successful response to INVITE
            if ($avp(rtpengine_answer_flags) != $null) {
                rtpengine_answer($avp(rtpengine_answer_flags));
            } else {
                rtpengine_answer();
            }
        }
    }
}

# Delete RTP session on call termination
route[RTPENGINE_DELETE] {
    rtpengine_delete();
}

# Handle DTMF for WebRTC clients
route[HANDLE_DTMF] {
    if ($ru =~ "transport=ws") {
        # WebRTC clients typically use RFC2833 or SIP INFO
        # RTPEngine will handle DTMF transcoding if needed
        $avp(rtpengine_offer_flags) = $avp(rtpengine_offer_flags) + " DTMF=RFC2833";
    }
}

# RTPEngine stats collection
route[RTPENGINE_STATS] {
    if (is_method("BYE")) {
        # Query RTPEngine for call statistics before deleting
        rtpengine_query();
        
        # Log statistics
        xlog("L_INFO", "Call statistics - CallID: $ci, Duration: $avp(rtpengine_duration), "
             "Packets: $avp(rtpengine_packets), Bytes: $avp(rtpengine_bytes), "
             "Loss: $avp(rtpengine_loss)\n");
    }
}

# WebRTC specific handling
route[WEBRTC] {
    if ($ru =~ "transport=ws") {
        # Force RTP/SAVPF profile for WebRTC
        $avp(rtpengine_offer_flags) = "trust-address replace-origin " +
                                      "replace-session-connection ICE=force " +
                                      "RTP/SAVPF DTLS=passive SDES-off";
        
        # Add TURN server information if needed
        $avp(rtpengine_offer_flags) = $avp(rtpengine_offer_flags) + 
                                      " ICE=force-relay STUN=$sel(cfg_get.rtpengine.stun_server)";
    }
}

# Transcoding route
route[TRANSCODE] {
    # Force transcoding between incompatible codecs
    if ($avp(force_transcode) == 1) {
        $avp(rtpengine_offer_flags) = $avp(rtpengine_offer_flags) + " transcode=always";
    }
    
    # Specific transcoding scenarios
    if ($fU =~ "^1") {
        # Numbers starting with 1 get opus
        $avp(rtpengine_offer_flags) = $avp(rtpengine_offer_flags) + " transcode-to=opus";
    } else if ($fU =~ "^2") {
        # Numbers starting with 2 get G.722
        $avp(rtpengine_offer_flags) = $avp(rtpengine_offer_flags) + " transcode-to=G722";
    }
}

# Main request route integration
route {
    # ... existing routes ...
    
    # Process NAT/RTP for INVITE
    if (is_method("INVITE")) {
        route(NATMANAGE);
        t_on_reply("REPLY_RTPENGINE");
        t_on_failure("RTPENGINE_FAILURE");
    }
    
    # Handle BYE
    if (is_method("BYE")) {
        route(RTPENGINE_STATS);
        route(RTPENGINE_DELETE);
    }
    
    # ... rest of routing logic ...
}

# Failure route
failure_route[RTPENGINE_FAILURE] {
    if (t_is_canceled()) {
        route(RTPENGINE_DELETE);
        exit;
    }
}

# Branch route for parallel forking
branch_route[RTPENGINE_BRANCH] {
    route(NATMANAGE);
}