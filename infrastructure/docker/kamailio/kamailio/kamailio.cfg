#!KAMAILIO
#
# WARP Platform - Kamailio Configuration
# Version: 5.7.x
# Features: PostgreSQL, WebSocket, TLS, RTPEngine integration
#

####### Global Parameters #########

### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
debug=__LOG_LEVEL__
log_stderror=yes

memdbg=5
memlog=5

log_facility=LOG_LOCAL0

fork=yes
children=8

/* uncomment the next line to enable debugging */
#debug_mode=yes

/* listen addresses */
# Note: advertise is used when Kamailio is behind NAT
listen=udp:__PRIVATE_IP__:5060 advertise __PUBLIC_IP__:5060
listen=tcp:__PRIVATE_IP__:5060 advertise __PUBLIC_IP__:5060
listen=tls:__PRIVATE_IP__:5061 advertise __PUBLIC_IP__:5061

# WebSocket interfaces (no advertise needed for these)
listen=tcp:__PRIVATE_IP__:__WEBSOCKET_PORT__
listen=tls:__PRIVATE_IP__:8443

/* set alias for easier handling */
alias="__SIP_DOMAIN__"
alias="__PUBLIC_IP__"

# Set server header
server_header="Server: WARP SIP Platform"
user_agent_header="User-Agent: WARP SIP Platform"

####### Modules Section ########

/* set paths to location of modules */
mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

# Load Redis database driver instead of PostgreSQL
loadmodule "db_redis.so"
#loadmodule "db_postgres.so"
loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "auth.so"
# Disabled database-dependent modules for Redis-only deployment
#loadmodule "auth_db.so"
loadmodule "permissions.so"  # Re-enabled for IP-based trunk authentication
#loadmodule "alias_db.so"
#loadmodule "speeddial.so"
#loadmodule "domain.so"
# Disabled presence - requires database
#loadmodule "presence.so"
#loadmodule "presence_xml.so"
loadmodule "nathelper.so"
loadmodule "rtpengine.so"
loadmodule "tls.so"
loadmodule "websocket.so"
loadmodule "xhttp.so"
loadmodule "dispatcher.so"
# Disabled dialplan - requires database
#loadmodule "dialplan.so"
# Disabled app_lua - requires routing.lua script and lua-cjson library
#loadmodule "app_lua.so"
loadmodule "htable.so"
loadmodule "pike.so"
loadmodule "ratelimit.so"
loadmodule "debugger.so"
loadmodule "cfgutils.so"
loadmodule "jansson.so"
loadmodule "rtimer.so"
#loadmodule "sqlops.so"  # Disabled - not needed for IP ACL authentication
loadmodule "uac.so"
loadmodule "dialog.so"
loadmodule "avpops.so"

# ----------------- setting module-specific parameters ---------------

# ----- db_redis params -----
modparam("db_redis", "schema_path", "/usr/share/kamailio/db_redis/kamailio")
# Keys definition for location table (usrloc)
modparam("db_redis", "keys", "location=entry:ruid&usrdom:username,domain&timer:partition,keepalive")
# Keys for dialog table
modparam("db_redis", "keys", "dialog=entry:hash_entry,hash_id&cid:callid")
# Keys for dispatcher table (SIP carriers)
modparam("db_redis", "keys", "dispatcher=entry:id")
# Keys for rtpengine table (RTPEngine instances with setid for load balancing)
modparam("db_redis", "keys", "rtpengine=entry:id")
modparam("db_redis", "verbosity", 1)

# ----- db_postgres params -----
# Disabled - using db_redis instead
#modparam("db_postgres", "retries", 3)
#modparam("db_postgres", "timeout", 5)

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
modparam("jsonrpcs", "transport", 1) # Enable HTTP transport

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)
modparam("tm", "auto_inv_100", 1)
modparam("tm", "auto_inv_100_reason", "Trying")

# ----- rr params -----
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)
modparam("rr", "enable_double_rr", 1)

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "min_expires", 60)
modparam("registrar", "default_expires", 600)
modparam("registrar", "gruu_enabled", 1)
modparam("registrar", "use_path", 1)
modparam("registrar", "path_mode", 0)

# ----- acc params -----
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
modparam("acc", "detect_direction", 1)
# Disabled PostgreSQL for acc - using syslog/external CDR collection
#modparam("acc", "db_url", "postgres://kamailio:__DB_PASS__@__DB_HOST__:__DB_PORT__/__DB_NAME__")
#modparam("acc", "db_flag", 1)
modparam("acc", "db_missed_flag", 2)
modparam("acc", "db_table_acc", "acc")
modparam("acc", "db_table_missed_calls", "missed_calls")
modparam("acc", "cdr_enable", 1)
modparam("acc", "cdr_extra", "src_ip=$si;dst_ip=$ru;src_user=$fU;dst_user=$tU;customer_id=$avp(customer_id)")
modparam("acc", "time_mode", 2)

# ----- usrloc params -----
# Using Redis for persistent registration storage across all Kamailio instances
modparam("usrloc", "db_url", "redis://__REDIS_HOST__:__REDIS_PORT__/__REDIS_DB__")
modparam("usrloc", "db_mode", 3) # DB only mode - shared state across cluster
modparam("usrloc", "use_domain", 1)
modparam("usrloc", "timer_interval", 60)
modparam("usrloc", "timer_procs", 4)
modparam("usrloc", "matching_mode", 1)
modparam("usrloc", "cseq_delay", 20)

# ----- auth_db params -----
# Disabled - using IP-based auth only for initial deployment
#modparam("auth_db", "db_url", "postgres://kamailio:__DB_PASS__@__DB_HOST__:__DB_PORT__/__DB_NAME__")
#modparam("auth_db", "calculate_ha1", 0)
#modparam("auth_db", "password_column", "password")
#modparam("auth_db", "load_credentials", "$avp(customer_id)=customer_id")
#modparam("auth_db", "use_domain", 1)

# ----- permissions params -----
# Using Redis for IP ACL storage (synced from PostgreSQL via API)
modparam("permissions", "db_url", "redis://__REDIS_HOST__:__REDIS_PORT__/__REDIS_DB__")
modparam("permissions", "db_mode", 1)  # Use database for permissions
modparam("permissions", "address_table", "address")
modparam("permissions", "grp_col", "grp")
modparam("permissions", "ip_addr_col", "ip_addr")
modparam("permissions", "mask_col", "mask")
modparam("permissions", "port_col", "port")
modparam("permissions", "proto_col", "proto")
# pattern_col and context_col removed in Kamailio 6.0 - use tag for customer BAN
modparam("permissions", "tag_col", "tag")
modparam("permissions", "peer_tag_avp", "$avp(peer_tag)")  # Will contain customer BAN
modparam("permissions", "peer_tag_mode", 1)  # Use tag column value

# ----- alias_db params -----
# Disabled PostgreSQL
#modparam("alias_db", "db_url", "postgres://kamailio:__DB_PASS__@__DB_HOST__:__DB_PORT__/__DB_NAME__")
#modparam("alias_db", "use_domain", 1)

# ----- speeddial params -----
# Disabled PostgreSQL
#modparam("speeddial", "db_url", "postgres://kamailio:__DB_PASS__@__DB_HOST__:__DB_PORT__/__DB_NAME__")
#modparam("speeddial", "use_domain", 1)

# ----- domain params -----
# Disabled PostgreSQL
#modparam("domain", "db_url", "postgres://kamailio:__DB_PASS__@__DB_HOST__:__DB_PORT__/__DB_NAME__")
#modparam("domain", "register_myself", 1)

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 0) # Disabled - requires nat_bflag in usrloc
modparam("nathelper", "received_avp", "$avp(RECEIVED)")
modparam("nathelper", "sipping_bflag", 7)
modparam("nathelper", "sipping_from", "sip:pinger@__SIP_DOMAIN__")
modparam("nathelper", "sipping_method", "OPTIONS")

# ----- rtpengine params -----
# Using Redis via dispatcher module for dynamic RTPEngine discovery
modparam("rtpengine", "db_url", "redis://__REDIS_HOST__:__REDIS_PORT__/__REDIS_DB__")
modparam("rtpengine", "table_name", "rtpengine")
modparam("rtpengine", "rtpengine_disable_tout", 20)
modparam("rtpengine", "rtpengine_tout_ms", 2000)
modparam("rtpengine", "rtpengine_retr", 2)
modparam("rtpengine", "extra_id_pv", "$avp(extra_id)")
modparam("rtpengine", "setid_avp", "$avp(rtpengine_setid)")
modparam("rtpengine", "setid_default", 0)
# Note: rtpengine_sock will be populated from dispatcher set at runtime

# ----- tls params -----
modparam("tls", "config", "/etc/kamailio/tls.cfg")
modparam("tls", "tls_method", "TLSv1.2+")

# ----- websocket params -----
modparam("websocket", "keepalive_mechanism", 2) # PING/PONG
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_interval", 10)
modparam("websocket", "keepalive_processes", 1)
modparam("websocket", "sub_protocols", 1)

# ----- dispatcher params -----
# Using Redis for dynamic RTPEngine and carrier management
modparam("dispatcher", "db_url", "redis://__REDIS_HOST__:__REDIS_PORT__/__REDIS_DB__")
modparam("dispatcher", "table_name", "dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "force_dst", 1)
# XAVP parameters (Kamailio 5.2+)
modparam("dispatcher", "xavp_dst", "dsdst")
modparam("dispatcher", "xavp_dst_mode", 0)
modparam("dispatcher", "xavp_ctx", "dsctx")
modparam("dispatcher", "xavp_ctx_mode", 0)
# Health checking for automatic failover
modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_ping_from", "sip:dispatcher@__SIP_DOMAIN__")
modparam("dispatcher", "ds_ping_interval", 10)
modparam("dispatcher", "ds_probing_threshold", 2)
modparam("dispatcher", "ds_inactive_threshold", 10)
modparam("dispatcher", "ds_probing_mode", 1)

# ----- dialplan params -----
# Disabled PostgreSQL
#modparam("dialplan", "db_url", "postgres://kamailio:__DB_PASS__@__DB_HOST__:__DB_PORT__/__DB_NAME__")

# ----- app_lua params -----
# Disabled - module not loaded
#modparam("app_lua", "load", "/usr/local/etc/kamailio/scripts/routing.lua")
#modparam("app_lua", "reload", 1)

# ----- htable params -----
# Rate limiting table
modparam("htable", "htable", "ratelimit=>size=16;autoexpire=300;")
# IP ban table  
modparam("htable", "htable", "ipban=>size=8;autoexpire=3600;")
# Active calls table
modparam("htable", "htable", "active_calls=>size=10;autoexpire=3600;")

# ----- pike params -----
modparam("pike", "sampling_time_unit", 10)
modparam("pike", "reqs_density_per_unit", 100)
modparam("pike", "remove_latency", 120)

# ----- ratelimit params -----
modparam("ratelimit", "timer_interval", 1)
# Note: pipe_replication_cluster is OpenSIPS-specific, not in Kamailio

# ----- debugger params -----
modparam("debugger", "cfgtrace", 1)
modparam("debugger", "log_level_name", "exec")

# ----- sqlops params -----
# Disabled - not needed for IP ACL authentication (using permissions module only)
#modparam("sqlops", "sqlcon", "redis=>redis://__REDIS_HOST__:__REDIS_PORT__/__REDIS_DB__")

# ----- dialog params -----
modparam("dialog", "enable_stats", 1)
# Using Redis for persistent dialog state across all Kamailio instances
modparam("dialog", "db_url", "redis://__REDIS_HOST__:__REDIS_PORT__/__REDIS_DB__")
modparam("dialog", "db_mode", 1) # Write-through cache mode
# dlg_flag parameter removed in Kamailio 6.0 - use dlg_flag() function in routing instead
modparam("dialog", "profiles_with_value", "customer;trunk")

####### Routing Logic ########

# Main SIP request routing logic
route {
    # Per-request initial checks
    route(REQINIT);

    # NAT detection
    route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # Handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # Handle requests within SIP dialogs
    route(WITHINDLG);

    # Handle presence related requests
    route(PRESENCE);

    # Authentication
    route(AUTH);

    # Record routing for dialog forming requests
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # Account only INVITEs
    if (is_method("INVITE")) {
        setflag(1); # do accounting
        
        # Create dialog state
        if(!dlg_isflagset(4)) {
            dlg_setflag(4);
            dlg_manage();
        }
        
        # Store customer info
        $dlg_var(customer_id) = $avp(customer_id);
        
        # Track in dialog profile
        if($avp(customer_id) != $null) {
            set_dlg_profile("customer", "$avp(customer_id)");
        }
    }

    # Handle registrations
    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }

    # Dispatch requests to carriers
    if (is_method("INVITE")) {
        route(PSTN);
    }

    # Handle other requests
    route(RELAY);
}

# Per SIP request initial checks
route[REQINIT] {
    # Enforce max_forwards
    if (!mf_process_maxfwd_header("70")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    # Check message size
    if (msg:len > 65536) {
        sl_send_reply("513", "Message Too Large");
        exit;
    }

    # Options keepalive
    if(is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200", "Keepalive");
        exit;
    }

    # Sanity check
    if(!sanity_check("17895", "7")) {
        xlog("L_WARN", "Malformed SIP request from $si:$sp\n");
        sl_send_reply("400", "Bad Request");
        exit;
    }

    # Rate limiting check  
    if (!pike_check_req()) {
        xlog("L_WARN", "Rate limit exceeded for $si\n");
        sl_send_reply("503", "Service Unavailable - Rate Limit");
        exit;
    }

    # Check if IP is banned
    if($sht(ipban=>$si) != $null) {
        xlog("L_WARN", "Blocked request from banned IP $si\n");
        sl_send_reply("403", "Forbidden");
        exit;
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) return;

    # Sequential request within a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        route(DLGURI);
        if (is_method("BYE")) {
            setflag(1); # do accounting
            setflag(3); # log failed transactions
        } else if (is_method("ACK")) {
            # ACK is forwarded statelessly
            route(NATMANAGE);
        } else if (is_method("NOTIFY")) {
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665
            record_route();
        }
        route(RELAY);
        exit;
    }

    if (is_method("ACK")) {
        if (t_check_trans()) {
            # no loose-route, but stateful ACK;
            # must be an ACK after a 487
            # or e.g. 404 from upstream server
            route(RELAY);
            exit;
        } else {
            # ACK without matching transaction
            exit;
        }
    }
    
    sl_send_reply("404", "Not Found");
    exit;
}

# Handle SIP registrations
route[REGISTRAR] {
    # Reject multi-domain registrations
    if ($rd != "__SIP_DOMAIN__") {
        sl_send_reply("403", "Forbidden - Invalid Domain");
        exit;
    }

    # Note: REGISTER is typically NOT used for wholesale trunk customers
    # This is for future hosted PBX/WebRTC scenarios only
    # For now, allow REGISTER from authenticated IPs (if customer_ban is set)
    # Or reject if no authentication context

    if ($avp(customer_ban) != $null) {
        xlog("L_INFO", "REGISTER for $tu from customer $avp(customer_ban) (IP: $si) - Hosted PBX mode\n");
    } else {
        # No IP authentication - reject (wholesale trunks don't register)
        xlog("L_WARN", "REGISTER attempt from unauthenticated IP $si - rejected\n");
        sl_send_reply("403", "Forbidden - Registrations not supported for trunk customers");
        exit;
    }

    # Save to location with customer context
    if (!save("location", "0x04")) {
        sl_reply_error();
        exit;
    }

    sl_send_reply("200", "OK");
    exit;
}

# Presence handling
route[PRESENCE] {
    if(!is_method("PUBLISH|SUBSCRIBE"))
        return;

    sl_send_reply("503", "Service Unavailable");
    exit;
}

# Authentication route
# IP-based authentication using permissions module
route[AUTH] {
    # TODO: Premium customer destination IP check (requires ndb_redis module)
    # For now, using standard tier only (source IP ACL via permissions module)

    # Standard customer: Check source IP against address table
    # Group 100 = customer trunks
    if (!allow_source_address_group()) {
        xlog("L_WARN", "Unauthorized IP: $si (proto=$pr, port=$sp)\n");
        sl_send_reply("403", "Forbidden - IP not authorized");
        exit;
    }

    # $avp(peer_tag) now contains customer BAN from address table
    $avp(customer_ban) = $avp(peer_tag);
    $avp(auth_method) = "IP_ACL";
    xlog("L_INFO", "Customer auth: BAN=$avp(customer_ban) via source IP $si\n");

    # TODO: Customer status validation (requires ndb_redis or HTTP API call)
    # For now, trusting that only active customers have IPs in the address table

    return;
}

# Caller NAT detection
route[NATDETECT] {
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if(is_first_hop())
                set_contact_alias();
        }
        setflag(5); # NAT flag
    }
    return;
}

# RTPengine control
route[NATMANAGE] {
    if (is_request()) {
        if(has_totag()) {
            if(check_route_param("nat=yes")) {
                setbflag(6);
            }
        }
    }
    
    if (!(isflagset(5) || isbflagset(6)))
        return;

    if(nat_uac_test("8")) {
        # Contact behind NAT
        if(is_request()) {
            if(!has_totag()) {
                if(t_is_branch_route()) {
                    add_rr_param(";nat=yes");
                }
            }
        }
    }

    # RTPengine for INVITE/200OK with SDP
    if (is_method("INVITE")) {
        if(has_body("application/sdp")) {
            # Set RTPengine flags based on transport
            $avp(rtpengine_flags) = "RTP/AVP replace-session-connection replace-origin ICE=remove";
            
            if(proto==WSS || proto==WS) {
                # WebRTC client
                $avp(rtpengine_flags) = "SDES-off ICE=force RTP/SAVPF replace-session-connection replace-origin rtcp-mux-offer generate-mid DTLS=passive";
            }
            
            # Determine media direction
            if($avp(peer_tag) == "carrier") {
                # From carrier to customer
                rtpengine_offer("$avp(rtpengine_flags) direction=external direction=internal");
            } else {
                # From customer to carrier  
                rtpengine_offer("$avp(rtpengine_flags) direction=internal direction=external");
            }
        }
    }
    
    if (is_reply()) {
        if(has_body("application/sdp")) {
            if(proto==WSS || proto==WS) {
                rtpengine_answer("SDES-off ICE=force RTP/SAVPF replace-session-connection replace-origin rtcp-mux-offer generate-mid DTLS=passive");
            } else {
                rtpengine_answer("RTP/AVP replace-session-connection replace-origin ICE=remove");
            }
        }
    }

    if(is_method("BYE|CANCEL")) {
        rtpengine_delete();
    }

    return;
}

# URI update for dialog requests
route[DLGURI] {
    if(!isdsturiset()) {
        handle_ruri_alias();
    }
    return;
}

# PSTN call routing
route[PSTN] {
    # Extract E164 from various formats
    if($rU =~ "^\+") {
        # International format - strip +
        $rU = $(rU{s.substr,1,0});
    } else if($rU =~ "^011") {
        # US international prefix - strip 011
        $rU = $(rU{s.substr,3,0});  
    } else if($rU =~ "^1" && $(rU{s.len}) == 11) {
        # US number with 1 - already in E164 format
        xlog("L_DBG", "Number already in E164 format\n");
    } else if($(rU{s.len}) == 10) {
        # US number without 1 - add it
        $rU = "1" + $rU;
    }

    # Enforce E164 (digits only after processing)
    if(!($rU =~ "^[0-9]+$")) {
        sl_send_reply("404", "Invalid Number Format");
        exit;
    }

    # Note: Lua LCR routing disabled - app_lua module not loaded
    # TODO: Re-enable when Lua routing script is ready
    # For now, using simple dispatcher-based routing
    #if(!lua_runstring("route_call()")) {
    #    sl_send_reply("503", "No Route Available");
    #    exit;
    #}
    #
    ## Check if routing was successful
    #if($avp(route_found) != "1") {
    #    sl_send_reply("404", "No Route Found");
    #    exit;
    #}

    # Set caller ID
    if($avp(force_clid) != $null) {
        uac_replace_from("sip:$avp(force_clid)@$fd");
    }

    # Add diversion header if needed
    if($avp(diversion) != $null) {
        append_hf("Diversion: <sip:$avp(diversion)@$fd>;reason=unconditional\r\n");
    }

    # Dispatcher to select specific carrier endpoint
    if($avp(carrier_id) != $null) {
        if(!ds_select_dst("$avp(carrier_id)", "4")) {
            sl_send_reply("503", "Carrier Unavailable");
            exit;
        }
    }

    route(RELAY);
    exit;
}

# Relay route
route[RELAY] {
    # Enable additional event routes for forwarded requests
    if (is_method("INVITE|BYE|UPDATE|CANCEL|ACK")) {
        if(!t_is_set("branch_route")) t_on_branch("BRANCH");
        if(!t_is_set("onreply_route")) t_on_reply("REPLY");  
        if (is_method("INVITE") && !has_totag()) {
            if(!t_is_set("failure_route")) t_on_failure("FAILURE");
        }
    }

    # NAT traversal
    route(NATMANAGE);

    # Relay the request
    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Branch route
branch_route[BRANCH] {
    xdbg("new branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
}

# Reply route - use onreply_route in Kamailio 5.x+
onreply_route[REPLY] {
    xdbg("incoming reply\n");
    if(status=~"[12][0-9][0-9]") {
        route(NATMANAGE);
    }
}

# Failure route
failure_route[FAILURE] {
    route(NATMANAGE);

    if (t_is_canceled()) {
        exit;
    }

    # Try next carrier if available
    if (t_check_status("503|408|500") && $avp(carrier_backup) != $null) {
        # Try backup route
        if (ds_next_dst()) {
            xlog("L_INFO", "Failing over to next carrier\n");
            t_relay();
            exit;
        }
    }
}

# WebSocket handling
event_route[xhttp:request] {
    if ($hdr(Upgrade)=~"websocket" && $hdr(Connection)=~"Upgrade" && $rm=~"GET") {
        # WebSocket handshake
        
        # Optional: validate Origin
        if ($hdr(Origin) != $null) {
            # Check if origin is allowed
            # For now, accept all origins in dev
            xlog("L_INFO", "WebSocket request from origin: $hdr(Origin)\n");
        }

        # Handle WebSocket handshake
        if (ws_handle_handshake()) {
            # Successful handshake
            exit;
        }
    }

    # Not a WebSocket request
    xhttp_reply("404", "Not Found", "text/html", "<html><body>Not Found</body></html>");
}

event_route[websocket:closed] {
    xlog("L_INFO", "WebSocket connection from $si:$sp has closed\n");
}

# Periodic timer routes
event_route[tm:local-request] {
    # Handle locally generated requests (e.g., OPTIONS keepalives)
    if(is_method("OPTIONS")) {
        append_hf("User-Agent: WARP Platform\r\n");
    }
}

# RPC/HTTP API Events
# Note: Disabled for now - requires additional jsonrpcs module configuration
# event_route[jsonrpc:request] {
#     # Handle JSON-RPC requests for monitoring/management
#     # Implement Prometheus metrics endpoint here
#     if ($jsonrpc(method) == "stats.get_all") {
#         # Return all statistics
#     }
# }