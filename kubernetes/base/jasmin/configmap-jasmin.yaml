apiVersion: v1
kind: ConfigMap
metadata:
  name: jasmin-config
  namespace: messaging
data:
  jasmin.cfg: |
    # Jasmin SMS Gateway Configuration
    
    [DEFAULT]
    # Log Level
    log_level = INFO
    log_file = /var/log/jasmin/jasmin.log
    log_rotate = W0
    log_format = %(asctime)s %(levelname)-8s %(process)d %(message)s
    log_date_format = %Y-%m-%d %H:%M:%S
    
    # PID
    pid_file = /var/run/jasmin/jasmin.pid
    
    [redis-client]
    host = ${REDIS_HOST}
    port = ${REDIS_PORT}
    dbid = 1
    password = 
    poolsize = 10
    
    [amqp-broker]
    host = ${RABBITMQ_HOST}
    port = ${RABBITMQ_PORT}
    vhost = /
    username = guest
    password = guest
    heartbeat = 60
    connection_loss_retry = true
    connection_failure_retry = true
    connection_retry_delay = 10
    
    [smpp-server]
    # SMPP Server for customer connections
    bind_host = 0.0.0.0
    bind_port = 2775
    bind_port_ssl = 2776
    ssl_certificate = /etc/jasmin/ssl/cert.pem
    ssl_privatekey = /etc/jasmin/ssl/key.pem
    
    # Throttling
    submit_sm_throughput = 500
    
    [http-api]
    bind_host = 0.0.0.0
    bind_port = 8080
    access_log = true
    log_file = /var/log/jasmin/http-access.log
    
    [jcli]
    # Jasmin CLI for management
    bind_host = 0.0.0.0
    bind_port = 8990
    authentication = true
    admin_username = admin
    admin_password = ${JASMIN_ADMIN_PASSWORD}

  jasmin-init.sh: |
    #!/bin/bash
    # Initialize Jasmin with vendor connectors
    
    sleep 30  # Wait for Jasmin to start
    
    # Connect to jCli and configure Sinch connector
    expect << EOF
    spawn telnet localhost 8990
    expect "Username:"
    send "admin\r"
    expect "Password:"
    send "${JASMIN_ADMIN_PASSWORD}\r"
    expect ">"
    
    # Add Sinch primary connector
    send "smppccm -a\r"
    expect "Adding a new connector:"
    send "cid sinch_primary\r"
    expect ">"
    send "host ${SINCH_HOST}\r"
    expect ">"
    send "port ${SINCH_PORT}\r"
    expect ">"
    send "username ${SINCH_USERNAME}\r"
    expect ">"
    send "password ${SINCH_PASSWORD}\r"
    expect ">"
    send "bind transceiver\r"
    expect ">"
    send "submit_throughput 100\r"
    expect ">"
    send "coding 0\r"
    expect ">"
    send "priority 1\r"
    expect ">"
    send "validity 1440\r"
    expect ">"
    send "ok\r"
    expect "Successfully added"
    
    # Add default routing
    send "mtrouter -a\r"
    expect "Adding a new route:"
    send "order 100\r"
    expect ">"
    send "type DefaultRoute\r"
    expect ">"
    send "connector smppc(sinch_primary)\r"
    expect ">"
    send "rate 0.0050\r"
    expect ">"
    send "ok\r"
    expect "Successfully added"
    
    send "quit\r"
    EOF

  interceptor.py: |
    """
    Jasmin interceptor for message processing and validation
    """
    import re
    import redis
    import json
    from datetime import datetime
    
    # Redis client for caching
    r = redis.Redis(host='${REDIS_HOST}', port=int('${REDIS_PORT}'), db=2)
    
    def clean_number(number):
        """Clean and normalize phone numbers"""
        # Remove any non-numeric characters
        cleaned = re.sub(r'[^\d]', '', number)
        
        # Add country code if missing
        if len(cleaned) == 10:  # US number without country code
            cleaned = '1' + cleaned
        
        return cleaned
    
    def check_10dlc_compliance(source, destination, content):
        """Check 10DLC compliance for US long codes"""
        # Check if source is US long code
        if source.startswith('1') and len(source) == 11:
            # Check campaign registration in cache/database
            campaign_key = f"10dlc:campaign:{source}"
            campaign = r.get(campaign_key)
            
            if not campaign:
                return False, "Unregistered 10DLC campaign"
            
            campaign_data = json.loads(campaign)
            
            # Check rate limits
            rate_key = f"10dlc:rate:{source}"
            current_rate = r.incr(rate_key)
            r.expire(rate_key, 60)  # 1 minute window
            
            if current_rate > campaign_data.get('rate_limit', 60):
                return False, "10DLC rate limit exceeded"
        
        return True, "OK"
    
    def jasmin_interception(message, route):
        """Main interception function called by Jasmin"""
        # Clean numbers
        message.source = clean_number(message.source)
        message.destination = clean_number(message.destination)
        
        # 10DLC compliance check
        compliant, reason = check_10dlc_compliance(
            message.source,
            message.destination,
            message.content
        )
        
        if not compliant:
            message.reject(reason)
            return False
        
        # Log message for billing
        billing_data = {
            'message_id': message.id,
            'account_id': route.user.uid,
            'source': message.source,
            'destination': message.destination,
            'segments': len(message.content) // 160 + 1,
            'rate': float(route.rate),
            'timestamp': datetime.utcnow().isoformat()
        }
        
        r.lpush('billing:queue', json.dumps(billing_data))
        
        return True