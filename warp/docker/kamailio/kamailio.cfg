#!KAMAILIO
#
# WARP Platform - Kamailio Configuration
# Version: 5.7.x
# Features: PostgreSQL, WebSocket, TLS, RTPEngine integration
#

####### Global Parameters #########

### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
debug=__LOG_LEVEL__
log_stderror=yes

memdbg=5
memlog=5

log_facility=LOG_LOCAL0

fork=yes
children=8

/* uncomment the next line to enable debugging */
#debug_mode=yes

/* listen addresses */
# Note: advertise is used when Kamailio is behind NAT
listen=udp:__PRIVATE_IP__:5060 advertise __PUBLIC_IP__:5060
listen=tcp:__PRIVATE_IP__:5060 advertise __PUBLIC_IP__:5060
listen=tls:__PRIVATE_IP__:5061 advertise __PUBLIC_IP__:5061

# WebSocket interfaces (no advertise needed for these)
listen=tcp:__PRIVATE_IP__:__WEBSOCKET_PORT__
listen=tls:__PRIVATE_IP__:8443

/* set alias for easier handling */
alias="__SIP_DOMAIN__"
alias="__PUBLIC_IP__"

# Set server header
server_header="Server: WARP SIP Platform"
user_agent_header="User-Agent: WARP SIP Platform"

####### Modules Section ########

/* set paths to location of modules */
mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule "db_postgres.so"
loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "auth.so"
loadmodule "auth_db.so"
loadmodule "permissions.so"
loadmodule "alias_db.so"
loadmodule "speeddial.so"
loadmodule "domain.so"
loadmodule "presence.so"
loadmodule "presence_xml.so"
loadmodule "nathelper.so"
loadmodule "rtpengine.so"
loadmodule "tls.so"
loadmodule "websocket.so"
loadmodule "xhttp.so"
loadmodule "dispatcher.so"
loadmodule "dialplan.so"
loadmodule "app_lua.so"
loadmodule "htable.so"
loadmodule "pike.so"
loadmodule "ratelimit.so"
loadmodule "debugger.so"
loadmodule "cfgutils.so"
loadmodule "jansson.so"
loadmodule "rtimer.so"
loadmodule "sqlops.so"
loadmodule "uac.so"
loadmodule "dialog.so"
loadmodule "avpops.so"

# ----------------- setting module-specific parameters ---------------

# ----- db_postgres params -----
modparam("db_postgres", "retries", 3)
modparam("db_postgres", "timeout", 5)

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
modparam("jsonrpcs", "transport", 1) # Enable HTTP transport

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)
modparam("tm", "auto_inv_100", 1)
modparam("tm", "auto_inv_100_reason", "Trying")

# ----- rr params -----
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)
modparam("rr", "enable_double_rr", 1)

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "min_expires", 60)
modparam("registrar", "default_expires", 600)
modparam("registrar", "gruu_enabled", 1)
modparam("registrar", "use_path", 1)
modparam("registrar", "path_mode", 0)

# ----- acc params -----
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
modparam("acc", "detect_direction", 1)
modparam("acc", "db_url", "postgres://kamailio:__DB_PASS__@__DB_HOST__:__DB_PORT__/__DB_NAME__")
modparam("acc", "db_flag", 1)
modparam("acc", "db_missed_flag", 2)
modparam("acc", "db_table_acc", "acc")
modparam("acc", "db_table_missed_calls", "missed_calls")
modparam("acc", "cdr_enable", 1)
modparam("acc", "cdr_extra", "src_ip=$si;dst_ip=$ru;src_user=$fU;dst_user=$tU;customer_id=$avp(customer_id)")
modparam("acc", "time_mode", 2)

# ----- usrloc params -----
modparam("usrloc", "db_url", "postgres://kamailio:__DB_PASS__@__DB_HOST__:__DB_PORT__/__DB_NAME__")
modparam("usrloc", "db_mode", 3) # DB only mode for cluster support
modparam("usrloc", "use_domain", 1)
modparam("usrloc", "timer_interval", 60)
modparam("usrloc", "timer_procs", 4)
modparam("usrloc", "matching_mode", 1)
modparam("usrloc", "cseq_delay", 20)

# ----- auth_db params -----
modparam("auth_db", "db_url", "postgres://kamailio:__DB_PASS__@__DB_HOST__:__DB_PORT__/__DB_NAME__")
modparam("auth_db", "calculate_ha1", 0)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "$avp(customer_id)=customer_id")
modparam("auth_db", "use_domain", 1)

# ----- permissions params -----
modparam("permissions", "db_url", "postgres://kamailio:__DB_PASS__@__DB_HOST__:__DB_PORT__/__DB_NAME__")
modparam("permissions", "db_mode", 1)
modparam("permissions", "trusted_table", "trusted")
modparam("permissions", "peer_tag_avp", "$avp(peer_tag)")

# ----- alias_db params -----
modparam("alias_db", "db_url", "postgres://kamailio:__DB_PASS__@__DB_HOST__:__DB_PORT__/__DB_NAME__")
modparam("alias_db", "use_domain", 1)

# ----- speeddial params -----
modparam("speeddial", "db_url", "postgres://kamailio:__DB_PASS__@__DB_HOST__:__DB_PORT__/__DB_NAME__")
modparam("speeddial", "use_domain", 1)

# ----- domain params -----
modparam("domain", "db_url", "postgres://kamailio:__DB_PASS__@__DB_HOST__:__DB_PORT__/__DB_NAME__")
modparam("domain", "register_myself", 1)

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", 7)
modparam("nathelper", "sipping_from", "sip:pinger@__SIP_DOMAIN__")
modparam("nathelper", "sipping_method", "OPTIONS")

# ----- rtpengine params -----
modparam("rtpengine", "rtpengine_sock", "__RTPENGINE_LIST__")
modparam("rtpengine", "rtpengine_disable_tout", 20)
modparam("rtpengine", "rtpengine_tout_ms", 2000)
modparam("rtpengine", "rtpengine_retr", 2)
modparam("rtpengine", "extra_id_pv", "$avp(extra_id)")
modparam("rtpengine", "db_url", "postgres://kamailio:__DB_PASS__@__DB_HOST__:__DB_PORT__/__DB_NAME__")
modparam("rtpengine", "table_name", "rtpengine")
modparam("rtpengine", "setid_avp", "$avp(setid)")
modparam("rtpengine", "setid_default", 0)

# ----- tls params -----
modparam("tls", "config", "/etc/kamailio/tls.cfg")
modparam("tls", "tls_method", "TLSv1.2+")

# ----- websocket params -----
modparam("websocket", "keepalive_mechanism", 2) # PING/PONG
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_interval", 10)
modparam("websocket", "keepalive_processes", 1)
modparam("websocket", "sub_protocols", 1)

# ----- dispatcher params -----
modparam("dispatcher", "db_url", "postgres://kamailio:__DB_PASS__@__DB_HOST__:__DB_PORT__/__DB_NAME__")
modparam("dispatcher", "table_name", "dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "force_dst", 1)
modparam("dispatcher", "dst_avp", "$avp(dsdst)")
modparam("dispatcher", "grp_avp", "$avp(dsgrp)")
modparam("dispatcher", "cnt_avp", "$avp(dscnt)")
modparam("dispatcher", "attrs_avp", "$avp(dsattrs)")
modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_ping_from", "sip:dispatcher@__SIP_DOMAIN__")
modparam("dispatcher", "ds_ping_interval", 10)
modparam("dispatcher", "ds_probing_threshold", 2)
modparam("dispatcher", "ds_inactive_threshold", 10)
modparam("dispatcher", "ds_probing_mode", 1)

# ----- dialplan params -----
modparam("dialplan", "db_url", "postgres://kamailio:__DB_PASS__@__DB_HOST__:__DB_PORT__/__DB_NAME__")

# ----- app_lua params -----
modparam("app_lua", "load", "/usr/local/etc/kamailio/scripts/routing.lua")
modparam("app_lua", "reload", 1)

# ----- htable params -----
# Rate limiting table
modparam("htable", "htable", "ratelimit=>size=16;autoexpire=300;")
# IP ban table  
modparam("htable", "htable", "ipban=>size=8;autoexpire=3600;")
# Active calls table
modparam("htable", "htable", "active_calls=>size=10;autoexpire=3600;")

# ----- pike params -----
modparam("pike", "sampling_time_unit", 10)
modparam("pike", "reqs_density_per_unit", 100)
modparam("pike", "remove_latency", 120)

# ----- ratelimit params -----
modparam("ratelimit", "timer_interval", 1)
modparam("ratelimit", "pipe_replication_cluster", 0)

# ----- debugger params -----
modparam("debugger", "cfgtrace", 1)
modparam("debugger", "log_level_name", "exec")

# ----- sqlops params -----
modparam("sqlops", "sqlcon", "warp=>postgres://kamailio:__DB_PASS__@__DB_HOST__:__DB_PORT__/__DB_NAME__")

# ----- dialog params -----
modparam("dialog", "enable_stats", 1)
modparam("dialog", "db_url", "postgres://kamailio:__DB_PASS__@__DB_HOST__:__DB_PORT__/__DB_NAME__")
modparam("dialog", "db_mode", 1)
modparam("dialog", "dlg_flag", 4)
modparam("dialog", "profiles_with_value", "customer;trunk")

####### Routing Logic ########

# Main SIP request routing logic
route {
    # Per-request initial checks
    route(REQINIT);

    # NAT detection
    route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # Handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # Handle requests within SIP dialogs
    route(WITHINDLG);

    # Handle presence related requests
    route(PRESENCE);

    # Authentication
    route(AUTH);

    # Record routing for dialog forming requests
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # Account only INVITEs
    if (is_method("INVITE")) {
        setflag(1); # do accounting
        
        # Create dialog state
        if(!dlg_isflagset(4)) {
            dlg_setflag(4);
            dlg_manage();
        }
        
        # Store customer info
        $dlg_var(customer_id) = $avp(customer_id);
        
        # Track in dialog profile
        if($avp(customer_id) != $null) {
            dlg_set_profile("customer", "$avp(customer_id)");
        }
    }

    # Handle registrations
    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }

    # Dispatch requests to carriers
    if (is_method("INVITE")) {
        route(PSTN);
    }

    # Handle other requests
    route(RELAY);
}

# Per SIP request initial checks
route[REQINIT] {
    # Enforce max_forwards
    if (!mf_process_maxfwd_header("70")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    # Check message size
    if (msg:len > 65536) {
        sl_send_reply("513", "Message Too Large");
        exit;
    }

    # Options keepalive
    if(is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200", "Keepalive");
        exit;
    }

    # Sanity check
    if(!sanity_check("17895", "7")) {
        xlog("L_WARN", "Malformed SIP request from $si:$sp\n");
        sl_send_reply("400", "Bad Request");
        exit;
    }

    # Rate limiting check  
    if (!pike_check_req()) {
        xlog("L_WARN", "Rate limit exceeded for $si\n");
        sl_send_reply("503", "Service Unavailable - Rate Limit");
        exit;
    }

    # Check if IP is banned
    if($sht(ipban=>$si) != $null) {
        xlog("L_WARN", "Blocked request from banned IP $si\n");
        sl_send_reply("403", "Forbidden");
        exit;
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) return;

    # Sequential request within a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        route(DLGURI);
        if (is_method("BYE")) {
            setflag(1); # do accounting
            setflag(3); # log failed transactions
        } else if (is_method("ACK")) {
            # ACK is forwarded statelessly
            route(NATMANAGE);
        } else if (is_method("NOTIFY")) {
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665
            record_route();
        }
        route(RELAY);
        exit;
    }

    if (is_method("ACK")) {
        if (t_check_trans()) {
            # no loose-route, but stateful ACK;
            # must be an ACK after a 487
            # or e.g. 404 from upstream server
            route(RELAY);
            exit;
        } else {
            # ACK without matching transaction
            exit;
        }
    }
    
    sl_send_reply("404", "Not Found");
    exit;
}

# Handle SIP registrations
route[REGISTRAR] {
    # Reject multi-domain registrations
    if ($rd != "__SIP_DOMAIN__") {
        sl_send_reply("403", "Forbidden - Invalid Domain");
        exit;
    }

    # Check source IP permissions
    if (!allow_source_address("1")) {
        # Try authentication
        if (!www_authenticate("$td", "subscriber")) {
            www_challenge("$td", "1");
            exit;
        }
        # Load customer info
        if (!check_to()) {
            sl_send_reply("403", "Forbidden");
            exit;
        }
    }

    # Save to location with customer context
    if (!save("location", "0x04")) {
        sl_reply_error();
        exit;
    }

    sl_send_reply("200", "OK");
    exit;
}

# Presence handling
route[PRESENCE] {
    if(!is_method("PUBLISH|SUBSCRIBE"))
        return;

    sl_send_reply("503", "Service Unavailable");
    exit;
}

# Authentication route
route[AUTH] {
    if (is_method("REGISTER|INVITE|BYE|ACK|PRACK|UPDATE|CANCEL")) {
        # Check if from trusted IP (carrier interconnect)
        if (allow_source_address("2")) {
            # Trusted carrier - load routing context
            $avp(peer_tag) = "carrier";
            return;
        }
        
        # Check if from customer IP
        if (allow_source_address("1")) {
            # Customer IP ACL - extract customer info
            sql_query("warp", "SELECT customer_id FROM ip_acl WHERE ip_address='$si' AND active=true", "res");
            if($dbr(res=>rows) > 0) {
                $avp(customer_id) = $dbr(res=>[0,0]);
                sql_result_free("res");
                return;
            }
            sql_result_free("res");
        }
        
        # Not in ACL - try authentication
        if (is_method("REGISTER")) {
            # Already handled in REGISTRAR route
            return;
        }
        
        # Authenticate other requests
        if (!proxy_authenticate("$fd", "subscriber")) {
            proxy_challenge("$fd", "1");
            exit;
        }
        
        # Load customer context from auth
        if (!check_from()) {
            sl_send_reply("403", "Forbidden");
            exit;
        }
        
        # Auth successful - load customer ID
        if($au != $null) {
            sql_query("warp", "SELECT customer_id FROM subscriber WHERE username='$au' AND domain='$fd'", "res");
            if($dbr(res=>rows) > 0) {
                $avp(customer_id) = $dbr(res=>[0,0]);
                sql_result_free("res");
            }
        }
    }
}

# Caller NAT detection
route[NATDETECT] {
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if(is_first_hop())
                set_contact_alias();
        }
        setflag(5); # NAT flag
    }
    return;
}

# RTPengine control
route[NATMANAGE] {
    if (is_request()) {
        if(has_totag()) {
            if(check_route_param("nat=yes")) {
                setbflag(6);
            }
        }
    }
    
    if (!(isflagset(5) || isbflagset(6)))
        return;

    if(nat_uac_test("8")) {
        # Contact behind NAT
        if(is_request()) {
            if(!has_totag()) {
                if(t_is_branch_route()) {
                    add_rr_param(";nat=yes");
                }
            }
        }
    }

    # RTPengine for INVITE/200OK with SDP
    if (is_method("INVITE")) {
        if(has_body("application/sdp")) {
            # Set RTPengine flags based on transport
            $avp(rtpengine_flags) = "RTP/AVP replace-session-connection replace-origin ICE=remove";
            
            if(proto==WSS || proto==WS) {
                # WebRTC client
                $avp(rtpengine_flags) = "SDES-off ICE=force RTP/SAVPF replace-session-connection replace-origin rtcp-mux-offer generate-mid DTLS=passive";
            }
            
            # Determine media direction
            if($avp(peer_tag) == "carrier") {
                # From carrier to customer
                rtpengine_offer("$avp(rtpengine_flags) direction=external direction=internal");
            } else {
                # From customer to carrier  
                rtpengine_offer("$avp(rtpengine_flags) direction=internal direction=external");
            }
        }
    }
    
    if (is_reply()) {
        if(has_body("application/sdp")) {
            if(proto==WSS || proto==WS) {
                rtpengine_answer("SDES-off ICE=force RTP/SAVPF replace-session-connection replace-origin rtcp-mux-offer generate-mid DTLS=passive");
            } else {
                rtpengine_answer("RTP/AVP replace-session-connection replace-origin ICE=remove");
            }
        }
    }

    if(is_method("BYE|CANCEL")) {
        rtpengine_delete();
    }

    return;
}

# URI update for dialog requests
route[DLGURI] {
    if(!isdsturiset()) {
        handle_ruri_alias();
    }
    return;
}

# PSTN call routing
route[PSTN] {
    # Extract E164 from various formats
    if($rU =~ "^\+") {
        # International format - strip +
        $rU = $(rU{s.substr,1,0});
    } else if($rU =~ "^011") {
        # US international prefix - strip 011
        $rU = $(rU{s.substr,3,0});  
    } else if($rU =~ "^1" && $(rU{s.len}) == 11) {
        # US number with 1 - already in E164
    } else if($(rU{s.len}) == 10) {
        # US number without 1 - add it
        $rU = "1" + $rU;
    }

    # Enforce E164 (digits only after processing)
    if(!($rU =~ "^[0-9]+$")) {
        sl_send_reply("404", "Invalid Number Format");
        exit;
    }

    # Lua LCR routing with caching
    if(!lua_runstring("route_call()")) {
        sl_send_reply("503", "No Route Available");
        exit;
    }

    # Check if routing was successful
    if($avp(route_found) != "1") {
        sl_send_reply("404", "No Route Found");
        exit;
    }

    # Set caller ID
    if($avp(force_clid) != $null) {
        uac_replace_from("sip:$avp(force_clid)@$fd");
    }

    # Add diversion header if needed
    if($avp(diversion) != $null) {
        append_hf("Diversion: <sip:$avp(diversion)@$fd>;reason=unconditional\r\n");
    }

    # Dispatcher to select specific carrier endpoint
    if($avp(carrier_id) != $null) {
        if(!ds_select_dst("$avp(carrier_id)", "4")) {
            sl_send_reply("503", "Carrier Unavailable");
            exit;
        }
    }

    route(RELAY);
    exit;
}

# Relay route
route[RELAY] {
    # Enable additional event routes for forwarded requests
    if (is_method("INVITE|BYE|UPDATE|CANCEL|ACK")) {
        if(!t_is_set("branch_route")) t_on_branch("BRANCH");
        if(!t_is_set("onreply_route")) t_on_reply("REPLY");  
        if (is_method("INVITE") && !has_totag()) {
            if(!t_is_set("failure_route")) t_on_failure("FAILURE");
        }
    }

    # NAT traversal
    route(NATMANAGE);

    # Relay the request
    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Branch route
branch_route[BRANCH] {
    xdbg("new branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
}

# Reply route
reply_route[REPLY] {
    xdbg("incoming reply\n");
    if(status=~"[12][0-9][0-9]") {
        route(NATMANAGE);
    }
}

# Failure route
failure_route[FAILURE] {
    route(NATMANAGE);

    if (t_is_canceled()) {
        exit;
    }

    # Try next carrier if available
    if (t_check_status("503|408|500") && $avp(carrier_backup) != $null) {
        # Try backup route
        if (ds_next_dst()) {
            xlog("L_INFO", "Failing over to next carrier\n");
            t_relay();
            exit;
        }
    }
}

# WebSocket handling
event_route[xhttp:request] {
    if ($hdr(Upgrade)=~"websocket" && $hdr(Connection)=~"Upgrade" && $rm=~"GET") {
        # WebSocket handshake
        
        # Optional: validate Origin
        if ($hdr(Origin) != $null) {
            # Check if origin is allowed
            # For now, accept all origins in dev
            xlog("L_INFO", "WebSocket request from origin: $hdr(Origin)\n");
        }

        # Handle WebSocket handshake
        if (ws_handle_handshake()) {
            # Successful handshake
            exit;
        }
    }

    # Not a WebSocket request
    xhttp_reply("404", "Not Found", "text/html", "<html><body>Not Found</body></html>");
}

event_route[websocket:closed] {
    xlog("L_INFO", "WebSocket connection from $si:$sp has closed\n");
}

# Periodic timer routes
event_route[tm:local-request] {
    # Handle locally generated requests (e.g., OPTIONS keepalives)
    if(is_method("OPTIONS")) {
        append_hf("User-Agent: WARP Platform\r\n");
    }
}

# RPC/HTTP API Events
event_route[jsonrpc:request] {
    # Handle JSON-RPC requests for monitoring/management
    # Implement Prometheus metrics endpoint here
    if ($jsonrpc(method) == "stats.get_all") {
        # Return all statistics
    }
}