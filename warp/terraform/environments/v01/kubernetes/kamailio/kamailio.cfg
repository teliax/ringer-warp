# Kamailio Configuration for WARP Platform
# Version: 5.7.x

####### Global Parameters #########
debug=2
log_stderror=yes
memdbg=5
memlog=5
log_facility=LOG_LOCAL0
fork=yes
children=4
auto_aliases=no

/* IP and port binding */
listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5060
listen=tls:0.0.0.0:5061
listen=tcp:0.0.0.0:8080 # WebSocket
listen=tls:0.0.0.0:8443 # WSS

/* Server header */
server_header="Server: WARP SIP Proxy"
user_agent_header="User-Agent: WARP SIP Proxy"

####### Modules Section ########
loadmodule "db_postgres.so"
loadmodule "mi_fifo.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "mi_rpc.so"
loadmodule "acc.so"
loadmodule "auth.so"
loadmodule "auth_db.so"
loadmodule "alias_db.so"
loadmodule "nathelper.so"
loadmodule "rtpengine.so"
loadmodule "tls.so"
loadmodule "websocket.so"
loadmodule "pike.so"
loadmodule "htable.so"
loadmodule "dispatcher.so"
loadmodule "dialog.so"
loadmodule "presence.so"
loadmodule "presence_xml.so"
loadmodule "json.so"
loadmodule "jsonrpcs.so"
loadmodule "http_async_client.so"

# ---- Module parameters ----

# ----- mi_fifo params -----
modparam("mi_fifo", "fifo_name", "/var/run/kamailio/kamailio_fifo")

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)

# ----- rr params -----
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "min_expires", 60)
modparam("registrar", "default_expires", 300)
modparam("registrar", "gruu_enabled", 1)
modparam("registrar", "use_path", 1)

# ----- acc params -----
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
modparam("acc", "detect_direction", 1)
modparam("acc", "db_flag", 1)
modparam("acc", "db_missed_flag", 2)
modparam("acc", "db_url", "postgres://warp:)T]!sXUi>SE+DeWt6a8Wmy*Q)A4q6R:}@10.126.0.3:5432/warp")

# ----- usrloc params -----
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "db_url", "postgres://warp:)T]!sXUi>SE+DeWt6a8Wmy*Q)A4q6R:}@10.126.0.3:5432/warp")
modparam("usrloc", "use_domain", 0)

# ----- auth_db params -----
modparam("auth_db", "db_url", "postgres://warp:)T]!sXUi>SE+DeWt6a8Wmy*Q)A4q6R:}@10.126.0.3:5432/warp")
modparam("auth_db", "calculate_ha1", 1)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "")

# ----- rtpengine params -----
modparam("rtpengine", "rtpengine_sock", "udp:warp-rtpengine-1:2223 udp:warp-rtpengine-2:2223 udp:warp-rtpengine-3:2223")
modparam("rtpengine", "rtpengine_disable_tout", 20)
modparam("rtpengine", "rtpengine_tout_ms", 2000)
modparam("rtpengine", "rtpengine_retr", 2)

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", 7)
modparam("nathelper", "sipping_from", "sip:pinger@warp.io")
modparam("nathelper", "sipping_method", "OPTIONS")

# ----- tls params -----
modparam("tls", "config", "/etc/kamailio/tls.cfg")

# ----- websocket params -----
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_processes", 1)
modparam("websocket", "keepalive_interval", 1)

# ----- pike params -----
modparam("pike", "sampling_time_unit", 10)
modparam("pike", "reqs_density_per_unit", 30)
modparam("pike", "remove_latency", 120)

# ----- htable params -----
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")

# ----- dispatcher params -----
modparam("dispatcher", "db_url", "postgres://warp:)T]!sXUi>SE+DeWt6a8Wmy*Q)A4q6R:}@10.126.0.3:5432/warp")
modparam("dispatcher", "table_name", "dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "force_dst", 1)
modparam("dispatcher", "ds_ping_interval", 10)
modparam("dispatcher", "ds_ping_latency_stats", 1)
modparam("dispatcher", "ds_probing_mode", 1)

# ----- dialog params -----
modparam("dialog", "db_url", "postgres://warp:)T]!sXUi>SE+DeWt6a8Wmy*Q)A4q6R:}@10.126.0.3:5432/warp")
modparam("dialog", "db_mode", 1)
modparam("dialog", "dlg_flag", 4)
modparam("dialog", "profiles_with_value", "caller;callee")

####### Routing Logic ########

# Main SIP request routing logic
route {
    # per request initial checks
    route(REQINIT);

    # NAT detection
    route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # handle requests within SIP dialogs
    route(WITHINDLG);

    # only initial requests (no To tag)
    
    # authentication
    route(AUTH);

    # record routing for dialog forming requests
    if (!is_method("REGISTER|MESSAGE"))
        record_route();

    # account only INVITEs
    if (is_method("INVITE")) {
        setflag(1); # do accounting
        dlg_manage();
    }

    # handle registrations
    route(REGISTRAR);

    if ($rU==$null) {
        # request with no Username in RURI
        sl_send_reply("484","Address Incomplete");
        exit;
    }

    # dispatch requests
    route(DISPATCH);

    route(RELAY);
}

# Per SIP request initial checks
route[REQINIT] {
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    if(is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200","Keepalive");
        exit;
    }

    if(!sanity_check("17895", "7")) {
        xlog("Malformed SIP request from $si:$sp\n");
        exit;
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) return;

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        route(DLGURI);
        if (is_method("BYE")) {
            setflag(1); # do accounting
        }
        route(RELAY);
        exit;
    }

    if ( is_method("ACK") ) {
        if ( t_check_trans() ) {
            # no loose-route, but stateful ACK;
            # must be an ACK after a 487
            # or e.g. 404 from upstream server
            route(RELAY);
            exit;
        } else {
            # ACK without matching transaction ... ignore and discard
            exit;
        }
    }
    sl_send_reply("404","Not here");
    exit;
}

# Handle SIP registrations
route[REGISTRAR] {
    if (!is_method("REGISTER")) return;

    if(isflagset(5)) {
        setbflag(6);
        # uncomment next line to do SIP NAT pinging
        ## setbflag(7);
    }
    if (!save("location")) {
        sl_reply_error();
    }
    exit;
}

# User location service
route[LOCATION] {
    if (!lookup("location")) {
        $var(rc) = $rc;
        t_newtran();
        switch ($var(rc)) {
            case -1:
            case -3:
                send_reply("404", "Not Found");
                exit;
            case -2:
                send_reply("405", "Method Not Allowed");
                exit;
        }
    }
}

# Authentication route
route[AUTH] {
    if (is_method("REGISTER") || from_uri==myself) {
        # authenticate requests
        if (!auth_check("$fd", "subscriber", "1")) {
            auth_challenge("$fd", "0");
            exit;
        }
        # user authenticated - remove auth header
        if(!is_method("REGISTER|PUBLISH"))
            consume_credentials();
    }
    # if caller is not local subscriber, then check if it calls
    # a local destination, otherwise deny, not an open relay here
    if (from_uri!=myself && uri!=myself) {
        sl_send_reply("403","Forbidden auth ID");
        exit;
    }
}

# Caller NAT detection
route[NATDETECT] {
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if(is_first_hop())
                set_contact_alias();
        }
        setflag(5);
    }
    return;
}

# RTPengine control
route[NATMANAGE] {
    if (is_request()) {
        if(has_totag()) {
            if(check_route_param("nat=yes")) {
                setbflag(6);
            }
        }
    }
    
    if (!has_totag()) {
        if(is_method("INVITE") && sdp_content()) {
            if(isflagset(5))
                rtpengine_offer("replace-origin replace-session-connection");
            else
                rtpengine_offer("trust-address replace-origin replace-session-connection");
        }
    }
    
    if (is_reply()) {
        if(isbflagset(6)) {
            if(is_method("INVITE") && sdp_content()) {
                rtpengine_answer("replace-origin replace-session-connection");
            }
        }
    }
}

# URI update for dialog requests
route[DLGURI] {
    if(!isdsturiset()) {
        handle_ruri_alias();
    }
    return;
}

# Dispatch requests
route[DISPATCH] {
    # round robin dispatching on gateways group '1'
    if(!ds_select_dst("1", "4")) {
        send_reply("404", "No destination");
        exit;
    }
    xlog("L_INFO", "--- SCRIPT: going to <$ru> via <$du> (attrs: $xavp(_dsdst_=>attrs))\n");
    t_on_failure("RTF_DISPATCH");
    return;
}

# Default relay function
route[RELAY] {
    # enable additional event routes for forwarded requests
    # - serial forking, RTP relaying handling, a.s.o.
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
    }
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    }
    if (is_method("INVITE")) {
        if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    }

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
    xlog("new branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
}

# Manage incoming replies
reply_route {
    if(!sanity_check("17604", "6")) {
        xlog("Malformed SIP response from $si:$sp\n");
        drop;
    }
}

# Manage incoming replies in transaction context
onreply_route[MANAGE_REPLY] {
    xlog("incoming reply\n");
    if(status=~"[12][0-9][0-9]") {
        route(NATMANAGE);
    }
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
    route(NATMANAGE);

    if (t_is_canceled()) exit;

    # next DST - only for 500 or local timeout
    if (t_check_status("500") || (t_branch_timeout() && !t_branch_replied())) {
        if(ds_next_dst()) {
            xlog("L_INFO", "--- SCRIPT: retrying to <$ru> via <$du> (attrs: $xavp(_dsdst_=>attrs))\n");
            t_on_failure("RTF_DISPATCH");
            route(RELAY);
            exit;
        }
    }
}

failure_route[RTF_DISPATCH] {
    if (t_is_canceled()) {
        exit;
    }
    # next DST - only for 500 or local timeout
    if (t_check_status("500") || (t_branch_timeout() && !t_branch_replied())) {
        if(ds_next_dst()) {
            t_on_failure("RTF_DISPATCH");
            route(RELAY);
            exit;
        }
    }
}